
import re
import os
import platform
from datetime import datetime


def remove_substrings(s: str, to_remove: set[str]) -> str:
    """Removes all substrings from the string s if they are present in the set to_remove.
    The removal is case-insensitive but preserves the original case of the remaining characters.

    Args:
        s: The string to remove substrings from.
        to_remove: A set of substrings to remove from the string s.

    Returns:
        String with all occurrences of substrings removed, with original case preserved.
    """
    for substring in to_remove:
        if not substring:  # Skip empty substrings
            continue
        # Use regex with IGNORECASE flag to find and remove all occurrences
        # while preserving the case of non-matching parts
        pattern = re.escape(substring)
        s = re.sub(pattern, '', s, flags=re.IGNORECASE)
    return s


def color_text(text, color_code):
    """Apply ANSI color code to text."""
    return f"\033[{color_code}m{text}\033[0m"


def highlight_removal(old_name: str, new_name: str, to_remove: set[str]) -> str:
    """Create a colored diff showing what will be removed.

    Args:
        old_name: Original filename
        new_name: New filename after removal
        to_remove: Set of substrings being removed

    Returns:
        Formatted string with removed parts highlighted in red with strikethrough
    """
    result = old_name

    # Find all matches and their positions
    matches = []
    for substring in to_remove:
        if not substring:
            continue
        pattern = re.escape(substring)
        for match in re.finditer(pattern, old_name, flags=re.IGNORECASE):
            matches.append((match.start(), match.end(), match.group()))

    # Sort by position (reverse to replace from end)
    matches.sort(key=lambda x: x[0], reverse=True)

    # Replace each match with strikethrough red version
    for start, end, matched_text in matches:
        highlighted = f"\033[9;31m{matched_text}\033[0m"  # Strikethrough + red
        result = result[:start] + highlighted + result[end:]

    return result


def format_preview_line(old_name: str, new_name: str, to_remove: set[str], item_type: str = "file") -> str:
    """Format a single preview line showing the rename operation.

    Args:
        old_name: Original filename
        new_name: New filename after removal
        to_remove: Set of substrings being removed
        item_type: "file" or "directory"

    Returns:
        Formatted preview line
    """
    icon = "ðŸ“" if item_type == "directory" else "ðŸ“„"
    highlighted_old = highlight_removal(old_name, new_name, to_remove)
    colored_new = color_text(new_name, "32")  # Green
    return f"  {icon} {highlighted_old} â†’ {colored_new}"


def generate_undo_script(rename_operations: list[tuple[str, str]], output_path: str) -> str:
    """Generate an undo script that reverses all rename operations.

    Args:
        rename_operations: List of (old_path, new_path) tuples
        output_path: Path where the undo script will be saved

    Returns:
        Path to the generated undo script
    """
    is_windows = platform.system() == "Windows"

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if is_windows:
        script_ext = ".bat"
        script_content = f"""@echo off
REM Undo script generated by butch-rename
REM Generated at: {timestamp}
REM This script will restore the original filenames

echo Restoring original filenames...
"""
        for old_path, new_path in reversed(rename_operations):
            # Escape quotes in paths for batch
            old_escaped = old_path.replace('"', '""')
            new_escaped = new_path.replace('"', '""')
            script_content += f'move "{new_escaped}" "{old_escaped}"\n'

        script_content += """
echo Done! All files have been restored.
pause
"""
    else:
        script_ext = ".sh"
        script_content = f"""#!/bin/bash
# Undo script generated by butch-rename
# Generated at: {timestamp}
# This script will restore the original filenames

echo "Restoring original filenames..."

"""
        for old_path, new_path in reversed(rename_operations):
            # Escape single quotes for bash
            old_escaped = old_path.replace("'", "'\"'\"'")
            new_escaped = new_path.replace("'", "'\"'\"'")
            script_content += f"mv '{new_escaped}' '{old_escaped}'\n"

        script_content += """
echo "Done! All files have been restored."
"""

    # Determine output filename
    if output_path:
        script_path = output_path
    else:
        script_path = f"undo_rename_{datetime.now().strftime('%Y%m%d_%H%M%S')}{script_ext}"

    # Ensure correct extension
    if is_windows and not script_path.endswith(".bat"):
        script_path += ".bat"
    elif not is_windows and not script_path.endswith(".sh"):
        script_path += ".sh"

    # Write the script
    with open(script_path, 'w', encoding='utf-8') as f:
        f.write(script_content)

    # Make executable on Unix
    if not is_windows:
        os.chmod(script_path, 0o755)

    return script_path


def create_progress_bar(current: int, total: int, width: int = 30) -> str:
    """Create a text-based progress bar.

    Args:
        current: Current progress value
        total: Total value
        width: Width of the progress bar in characters

    Returns:
        Formatted progress bar string
    """
    if total == 0:
        percentage = 100
        filled = width
    else:
        percentage = int(current / total * 100)
        filled = int(width * current / total)

    bar = "â–ˆ" * filled + "â–‘" * (width - filled)
    return f"[{bar}] {percentage}%"


def should_process_file(filename: str, extensions: list[str] | None) -> bool:
    """Check if a file should be processed based on extension filter.

    Args:
        filename: The filename to check
        extensions: List of extensions to include (e.g., ['.txt', '.pdf'])
                   If None or empty, all files are included

    Returns:
        True if file should be processed, False otherwise
    """
    if not extensions:
        return True

    _, ext = os.path.splitext(filename)
    ext = ext.lower()

    # Normalize extensions (ensure they start with dot)
    normalized_exts = []
    for e in extensions:
        if not e.startswith('.'):
            e = '.' + e
        normalized_exts.append(e.lower())

    return ext in normalized_exts
